\section{The Solver}
\label{solve}


This section describes how to use \textit{spec.x}. This executable computes the seismic wavefield
induced by a force or a double-couple in a velocity model defined by the user. To create \textit{spec.x},
source codes in the directory \textit{\bfseries SOLVE/src} have to be compiled:
\begin{enumerate}
\item Get into \textit{\bfseries SOLVE/src} and specify your C and MPI Fortran 90 compilers in
\textit{Makefile}.
\item Do \texttt{make}. The compilation starts. It lasts a couple of minutes and then creates \textit{spec.x}
in the directory \textit{\bfseries SOLVE/bin}.
\end{enumerate}




\subsection{Inputs}


Running \textit{spec.x} requires three types of input files (paragraph \ref{meshfile} to \ref{elasticfile})
and a Fortran module which provides the velocity model of the region under study (paragraph \ref{readmodel}).
Depending on the input parameters, additional files may be required (paragraph \ref{stafile} and
\ref{src_adj_file}).


\subsubsection{Mesh files}
\label{meshfile}

These files are provided by the mesher (see subsection \ref{mesh4spec}). Each of them describes the mesh of
the subdomain associated with a given processor: \textit{mesh4spec.XXX} corresponds to the
$\mbox{\textit{XXX}}^{\mbox{th}}$ processor.


\subsubsection{\textit{input.spec}}
\label{input.spec}

This is the most important file. It defines crucial parameters and describes the source(s).

\renewcommand{\labelitemii}{}
\begin{itemize}[itemsep=10pt]

\item\underline{duration}: Duration of the propagation (in s).

\item\underline{mesh\_file}: Root name of the files which describe the mesh (i.e. \textit{mesh4spec.}).

\item\underline{mat\_file}: Name of the material file (see paragraph \ref{elasticfile}).

\item\underline{anisotropy}: tells if the anisotropy is considered. If \textit{true},
then subroutine \textit{get\_value\_aniso} will be used to get the elastic parameters at each GLL point. If
\textit{false}, then \textit{get\_value} will be used (see paragraph \ref{readmodel}).

\item\underline{ocean}: tells if the mass of the oceans is considered. This option works only if a
topography with n\_nodes = 27 (see subsection \ref{mesh4spec}) is imposed at the free surface.

\item\underline{traces}: tells if receivers are used and seismograms are returned (see paragraph
\ref{outputtraces}). If \textit{true}, then a station file is needed (paragraph \ref{stafile}).

\item\underline{rcv\_file}: Name of the station file. This is required if traces = \textit{true}.

\item\underline{comp\_rot}: tells if a component rotation of the output traces (from Z/N/E to Z/R/T) needs to
be performed. T is oriented such that (Z,R,T) is a direct basis. This option works only if traces = \textit{true}, n\_src = \textit{1} (see below) and curve =
\textit{true} (see subsection \ref{mesh4spec}).

\item\underline{samp\_period}: Period at which the output traces are returned. This is useful because the
time-step of the time-marching is often much smaller than the Nyquist period. This option works only if traces
= \textit{true}. Write \textit{0} for no resampling.

\item\underline{snapshots}: tells if snapshots of the norm of the displacement are returned (see paragraph
\ref{outputshots}).

\item\underline{time\_interval}: Number of time-steps between two snapshots. This option works only if
snapshots = \textit{true}. No more than 1000 snapshots can be provided.

\item\underline{npts\_x, npts\_y, npts\_z}: Number of output points for the snapshots in the x, y, z direction in each element.

\item\underline{attenuation}: Number of linear solids to mimick the attenuation (usually \textit{3}).
Write \textit{0} for no attenuation.

\item\underline{attenuation\_band}: Two periods (in s) defining the attenuation band. This works only if
attenuation > \textit{0}. Usually, a band larger than the source spectrum is introduced.

\item\underline{adjoint}: If \textit{true}, then there will be two simulations in the same run: one computing
a regular wavefield and another computing an adjoint wavefield. This process allows to calculate misfit kernels
(paragraph \ref{adjkern}). Usually, the regular wavefield is reconstructed using a time-reversal mirror
(TRmirror = \textit{2}, see below). This is necessary to calculate the kernels on the fly and to avoid the
storage of the whole wavefield. The adjoint wavefield is generated by sources specified in the file
\textit{src\_adj} (paragraph \ref{src_adj_file}).

\item\underline{TRmirror}: (1) yields the recording of the displacement on the mirror defined when
building the mesh (see subsection \ref{input_mesh}). One binary output file per processor is then created:
\textit{mirrorXXX}, where \textit{XXX} corresponds to the number assigned to the processor. (2) yields
the back-propagation of the time-reversed displacement recorded in the \textit{mirrorXXX} files. In this case,
the point-source defined in \textit{input.spec} is also time-reversed. (0) yields no mirror.

\item\underline{n\_init}: Number of time-steps between two point-matchings. The point-matching is necessary to stabilize the amplification when back-propagating a wavefield in a attenuating medium.

\item\underline{n\_src}: Number of sources (usually \textit{1}).

\item\underline{coord\_src}: Location of the source. If curve = \textit{false}, then cartesian coordinates
$x,y,z$ are expected. If curve = \textit{true}, then spherical coordinates $\theta$(latitude),
$\phi$(longitude), $D$(depth -in m-) are expected.

\item\underline{src\_type}: Type of the source. (1) refers to a pulse and (2) refers to a seismic moment tensor.

\item\underline{pulse\_dir}: Components of the pulse, i.e. $A_X$, $A_Y$, $A_Z$ if curve = \textit{false} or
$A_r$, $A_\theta$(northward), $A_\phi$ if curve = \textit{true}. This works only if src\_type = \textit{1}.

\item\underline{M\_diag}: Values of the three diagonal terms of the moment tensor expressed in the spherical
system. This works only if src\_type = \textit{2}.

\item\underline{M\_non\_diag}: Values of the three non-diagonal terms of the moment tensor expressed in the
spherical system. This works only if src\_type = \textit{2}.

\item\underline{time\_func}: Source time-function. (1) gives a Gaussian with a standard deviation
$\sigma = \mbox{t0}/(3.256\sqrt{2})$, where t0 is a parameter defined below. This kind of Gaussian is
equivalent to a triangular function with a duration equal to t0. (2) gives the derivative of the Gaussian,
which is a Ricker. (3) makes the inverse Fourier transform of a bandwidth defined below. (4) gives
the antiderivative of the Gaussian, which is an error-function.

\item\underline{t0}: Time-shift (in $s$) applied to the source time-function.

\item\underline{bandwidth}: Four frequencies (f1, f2, f3 and f4 -in $Hz$-) which define the spectrum of the
third source time-function. The spectrum is 0 below f1, a cosine-taper between f1 and f2, 1 between f2 and f3,
a cosine-taper between f3 and f4, and 0 above f4. This is required if time\_func = \textit{3}

\end{itemize}


\subsubsection{Material file}
\label{elasticfile}

Each line of this file defines a "material". To use \textit{RegSEM}, it is not necessary to know the format of
this file and what "material" means. Two different material files are provided: \textit{elastic\_8\_8} in
\textit{\bfseries WORKDIR1} (see paragraph \ref{expl_PREM}) and \textit{elastic\_8\_4} in \textit{\bfseries
WORKDIR2} (see paragraph \ref{expl_CUB}). The user can use one of them. The two numbers in the name of the file
refer to $N_{PML}$ (the polynomial order in the damping directions of the PML) and $N$ (the polynomial order in
the normal elements), so the user just needs to know what he wants and write the name of the corresponding
file in \textit{input.spec} (paragraph \ref{input.spec}).\\

Here is the structure of a material file:

\renewcommand{\labelitemii}{}
\begin{itemize}[topsep=2pt,itemsep=10pt]

\item\underline{n\_mat}: Number of materials.
It is supposed to be \textit{27}.\\
\underline{special\_NGLLz\_crust} : In the crust, it is possible to use a particular number of GLL points in
the vertical direction. This option is not available yet, so write \textit{0}.

\item\underline{type, GLLx, GLLy, GLLz}: defines each material by a type (\textit{S} for solid or
\textit{P} for PML) and a number of GLL points per directions.

\item\underline{n, A, PMLx, Left, PMLy, Front, PMLz, Bottom}: tell for each PML material the two dumping
coefficients (n = \textit{2} and A = \textit{10}) and the position in the domain.
PMLx (resp PMLy, PMLz) tells if $x$ (resp $y$, $z$) is a dumping direction or not. If PMLx = \textit{true} 
(resp PMLy, PMLz) then Left (resp Front, Bottom) tells if the dumping is according to the decreasing $x$
(resp $y$, $z$) or not.

\end{itemize}


\subsubsection{\textit{read\_model.f90}}
\label{readmodel}

This Fortran module contains two routines: \textit{get\_value} and \textit{get\_value\_aniso}. These routines
return the seismic velocities and the density at any location in the chunk.\\
\textit{read\_model.f90} has to be placed in the directory \textit{\bfseries SOLVE/src/Modules}. When changing
\textit{read\_model.f90} (i.e. when the user wants to change the velocity model of the Earth), the whole solver
needs to be recompiled.\\ 
Three different \textit{read\_model.f90} modules, corresponding to three different models, are provided in
\linebreak \textit{\bfseries SOLVE/src/Modules}. They are stored in subdirectories which have explicit names:
\textit{\bfseries Homogeneous}, \textit{\bfseries PREM} and \textit{\bfseries CUB}. These modules can be used
by the user. They can also help him to create his own \textit{read\_model.f90} module, i.e. to implement the
model he wants in \textit{RegSEM}.\\

The arguments of the two routines \textit{get\_value} and \textit{get\_value\_aniso} are the followings:

\renewcommand{\labelitemii}{}
\begin{itemize}[topsep=2pt,itemsep=10pt]

\item \textit{get\_value (i, j, k, rho, vp, vs, Qmu, moho)}:

\renewcommand{\labelitemii}{}
\begin{itemize}[topsep=2pt,itemsep=4pt]

\item\textit{i, j, k} are double precision inputs which correspond to the spatial coordinates of a point.
Cartesian coordiantes $x$, $y$, $z$ (in $m$) are expected when working in a parallelepipedic chunk (curve =
\textit{false}). Spherical coordinates $r$, $\theta$(colatitude), $\phi$(longitude) (in $m$ and positive
radian, respectively) are expected when working in a spherical chunk (curve = \textit{true}).
\item\textit{rho, vp, vs, Qmu} are double precision outputs.
\textit{rho} is the density (in $kg.m^{-3}$), \textit{vp} and \textit{vs} are the P and S wave velocities (in
$m.s^{-1}$) and \textit{Qmu} is the quality factor. Note that \textit{Qmu} has to be provided even if no
attenuation is introduced in the simulation (attenuation = \textit{0} in \textit{input.spec}, see paragraph
\ref{input.spec}).
\item\textit{moho} is an optional integer input.
It tells if the point \textit{i, j, k} is in an element just below the Moho (\textit{-1}),
just above the Moho (\textit{1}) or elsewhere (\textit{0}).
This argument is useful to perfectly fit the elastic discontinuity to the 3D interface of the mesh.

\end{itemize}

\item \textit{get\_value\_aniso (i, j, k, rho, A, C, F, L, M, Gc, Gs, Hc, Hs, Bc, Bs, Ec, Es, Qmu, moho)}:

\renewcommand{\labelitemii}{}
\begin{itemize}[topsep=2pt,itemsep=4pt]

\item\textit{i, j, k, rho, Qmu} and \textit{moho} are the same as in \textit{get\_value}.
\item\textit{A, C, F, L, M, Gc, Gs, Hc, Hs, Bc, Bs, Ec, Es} are double precision outputs which correspond to the
anisotropic parameters defined by \Citet{MontagnerNataf86}.

\end{itemize}

\end{itemize}


\subsubsection{Station file (optional)}
\label{stafile}

This file is required if traces = \textit{true} (see paragraph \ref{input.spec}). Its content is:

\renewcommand{\labelitemii}{}
\begin{itemize}[topsep=2pt,itemsep=10pt]

\item\underline{n\_rcv}: Number of receivers.

\item\underline{rcv\_name}: Name of each receiver.\\
\underline{coord\_rcv}: Coordinates of each receiver.
Cartesian coordiantes $x$, $y$, $z$ (in $m$) are expected when working in a parallelepipedic chunk (curve = 
\textit{false}). Spherical coordinates $\theta$(latitude), $\phi$(longitude), $z$(elevation) (in degree and
$m$, respectively) are expected when working in a spherical chunk (curve = \textit{true}).
 
\end{itemize}


\subsubsection{\textit{src\_adj} (optional)}
\label{src_adj_file}

This file is required if adjoint = \textit{true} (see paragraph \ref{input.spec}). It contains the position
and the time function associated with the adjoint sources:

\renewcommand{\labelitemii}{}
\begin{itemize}[topsep=2pt,itemsep=10pt]

\item\underline{n\_adj\_src}: Number of adjoint sources.

\item\underline{adj\_coord}: Coordinates of each adjoint source.
Cartesian coordinates $x$, $y$, $z$ (in $m$) are expected when working in a parallelepipedic chunk (curve =
\textit{false}). Spherical coordinates $\theta$(latitude), $\phi$(longitude), $d$(depth) (in degree and
$m$, respectively) are expected when working in a spherical chunk (curve = \textit{true}).\\
\underline{n\_timestep}: Number of time-step in the simulation. Prior to the simulation which computes the
adjoint wavefield, the user should have performed a simulation to record the regular wavefield on a mirror
(TRmirror = \textit{1}, see paragraph \ref{input.spec}).  The number of time-step in the adjoint simulation
must be the same as the one in the first simulation.\\
\underline{adj\_timefunc}: Components of the adjoint force, i.e. $A_X$, $A_Y$, $A_Z$ if curve =
\textit{false} or $A_r$, $A_\theta$(northward), $A_\phi$ if curve = \textit{true}, for each time-step.

\end{itemize}




\subsection{Outputs}


\subsubsection{Output messages}
\label{print_output}

When the code is running, lots of messages inform the user on how things are going. First, all the arrays are
allocated and initialized. Then the time step is calculated and returned with the number of iteration.
Finally, the iterative process starts: after each iteration, the code returns the number of the current
iteration and the time it took (in $s$), so the user can estimate the computation time of the whole
simulation.


\subsubsection{\textit{sgn\_src} (optional)}

If the time-function associated with the first source introduced in the file \textit{input.spec} is the
inverse Fourier transform of a bandwidth (time\_func = \textit{3}, see paragraph \ref{input.spec}), then a
text file containing this time-function is created.


\subsubsection{Traces (optional)}
\label{outputtraces}

If traces = \textit{true} (see paragraph \ref{input.spec}), then text files containing synthetic seismograms
are created. For each receiver, there are three files. Each of them refers to a component. For example,
\textit{SSB\_T} contains the tranverse component of the displacement at station SSB. The files are composed by
two columns: the time (in $s$) and the value of the displacement (in $m$).


\subsubsection{Snapshots (optional)}
\label{outputshots}

If snapshots = \textit{true} (see paragraph \ref{input.spec}), then text files containing the norm of the
displacement at the GLL points which are inside the elements are created. If adjoint = \textit{true}, then
snapshots of the adjoint wavefield are also returned. The files are composed by four columns: three coordinates
($x$, $y$, $z$ in $km$ when working in a parallelepipedic chunk; $\theta$, $\phi$, $r$ in degree and $km$,
respectively, when working in a spherical chunk) and the norm of the displacement (in $m$).


\subsubsection{Adjoint kernels (optional)}
\label{adjkern}

If adjoint = \textit{true} (see paragraph \ref{input.spec}), then a text file containing the value of the
S-wave misfit kernel at the GLL points which are inside the elements is created. This file is
\textit{kern\_beta}. If anisotropy = \textit{true}, then \textit{kern\_xi} (the misfit kernel of the transverse
isotropic paramater $\xi$) is also created. These files  are composed by four columns: three coordinates ($x$,
$y$, $z$ in $km$ when working in a parallelepipedic chunk; $\theta$, $\phi$, $r$ in degree and $km$,
respectively, when working in a spherical chunk) and the value of the kernel.\\
Note that in practice the kernels of the density $\rho$ and the Lam\'e parameters $\lambda$ and $\mu$ are
calculated at every GLL points (see the routines \textit{kernel\_rho.f90} and \textit{kernel\_iso.f90} in the
directory \textit{\bfseries SOLVE/src}). In anisotropic media, the kernels of the anisotropic parameters $A$,
$C$, $F$, $L$ and $N$ are calculated instead of the Lam\'e parameter kernels (see the routine
\textit{kernel\_aniso.f90}).
